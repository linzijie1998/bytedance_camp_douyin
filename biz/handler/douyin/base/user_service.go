// Code generated by hertz generator.

package base

import (
	"context"
	"fmt"
	"github.com/linzijie1998/bytedance_camp_douyin/biz/handler/douyin"
	"github.com/linzijie1998/bytedance_camp_douyin/global"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/linzijie1998/bytedance_camp_douyin/biz/dal"
	base "github.com/linzijie1998/bytedance_camp_douyin/biz/model/douyin/base"
	"github.com/linzijie1998/bytedance_camp_douyin/model"
	"github.com/linzijie1998/bytedance_camp_douyin/util"
	"golang.org/x/crypto/bcrypt"
)

// UserRegister 用户注册服务, 对用户密码进行加密存储, 并且对用户信息UserInfo进行初始化.
// @router /douyin/user/register/ [POST]
func UserRegister(ctx context.Context, c *app.RequestContext) {
	var err error
	var req base.UserRegisterReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(base.UserRegisterResp)

	// 查询是否已经注册
	loginInfos, err := dal.QueryLoginInfoByUsername(req.Username)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("注册时查询用户登录表失败 err: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}
	if len(loginInfos) > 1 {
		global.DOUYIN_LOGGER.Warn(fmt.Sprintf("用户注册表出现多条相同Username为%s的记录", req.Username))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	if len(loginInfos) == 1 {
		global.DOUYIN_LOGGER.Info(fmt.Sprintf("Username为%s的用户尝试多次进行注册", req.Username))
		resp.StatusCode = 1
		c.JSON(consts.StatusOK, resp)
		return
	}

	// 密码加密
	hash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("Password: %s 加密失败 err: %v", req.Password, err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 创建实例
	loginInfo := model.UserLogin{
		Username: req.Username,
		Password: string(hash),
	}
	userInfo := model.UserInfo{
		Username: req.Username,
		Name:     req.Username,
	}

	// 执行数据库事务
	if err := dal.UserRegister(&loginInfo, &userInfo); err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("注册时添加用户信息失败: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 签发Token
	j := util.NewJWT()
	token, err := j.CreateToken(userInfo)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("注册完成后签发Token失败: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	resp.UserID = int64(userInfo.ID) // 返回UserInfo的ID
	resp.Token = token
	c.JSON(consts.StatusOK, resp)
	global.DOUYIN_LOGGER.Info(fmt.Sprintf("Username为%s的用户注册成功", req.Username))
}

// UserLogin .
// @router /douyin/user/login/ [POST]
func UserLogin(ctx context.Context, c *app.RequestContext) {
	var err error
	var req base.UserLoginReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(base.UserLoginResp)

	// 登录信息查询
	loginInfos, err := dal.QueryLoginInfoByUsername(req.Username)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("查询登录信息失败: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}
	if len(loginInfos) != 1 {
		global.DOUYIN_LOGGER.Warn(fmt.Sprintf("查询到%d条的Username为%s的用户登录信息", len(loginInfos), req.Username))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 用户信息查询
	userInfos, err := dal.QueryUserInfoByUsername(req.Username)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("查询用户信息失败: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	if len(userInfos) != 1 {
		global.DOUYIN_LOGGER.Warn(fmt.Sprintf("查询到%d条的Username为%s的用户信息", len(userInfos), req.Username))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 密码认证
	if err := bcrypt.CompareHashAndPassword([]byte(loginInfos[0].Password), []byte(req.Password)); err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("密码认证失败 err: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// 颁发Token
	j := util.NewJWT()
	token, err := j.CreateToken(userInfos[0])
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("Token签发失败 err: %v", err))
		resp.StatusCode = 1
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	// 设置响应体
	resp.StatusCode = 0
	resp.Token = token
	resp.UserID = int64(userInfos[0].ID)
	c.JSON(consts.StatusOK, resp)
}

// UserInfo .
// @router /douyin/user/ [GET]
func UserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req base.UserInfoReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(base.UserInfoResp)

	var userID int64
	// 登录状态下查看用户信息
	if req.Token != "" {
		j := util.NewJWT()
		claim, err := j.ParseToken(req.Token)
		if err != nil {
			global.DOUYIN_LOGGER.Info(fmt.Sprintf("Token解析失败 err: %v", err))
			resp.StatusCode = 1
			c.JSON(consts.StatusBadRequest, resp)
			return
		}
		userID = int64(claim.UserInfo.ID)
	}

	userInfos, err := dal.QueryUserInfoByUserID(req.UserID)
	if err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("查询用户信息失败: %v", err))
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}
	if len(userInfos) != 1 {
		global.DOUYIN_LOGGER.Warn(fmt.Sprintf("查询到%d条的ID为%d的用户信息", len(userInfos), req.UserID))
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}

	var user = new(base.User)
	user.ID = int64(userInfos[0].ID)
	if err = douyin.UserInfoSupplement(userID, user, &userInfos[0]); err != nil {
		global.DOUYIN_LOGGER.Debug(fmt.Sprintf("查询用户信息补充失败 err:%v", err))
		return
	}

	resp.User = user
	resp.StatusCode = 0
	c.JSON(consts.StatusOK, resp)
}
